 - first 16 bit microprocessor from intel released in 1978
	 - alu / internal registers / most instructions are designed to work with 16 bit binary words
 - parts
	 - 16 bit databaus and 20 bit address bus
		 - 1 megabyte memory locations
	 - has 64k io ports
	 - 14, 16bit registers
	 - multiplexed address and databus between AD0-AD15 and A16 and A19
 - 8088 has the same alu but it only has a 8-bit databus
 - has 2 modes of operation dictated by the MN/MX pin (active low)
	 - minimum mode (when pin is High)
		 - does not associate with any co-processor and cannot be used in multiprocessor systems
	 - maximum mode (when min is low)
		 - multiprocessor or coprocessor configuration
 - prefetches up to 6 bytes from memory and queues them in order to speed up the processing
## Architecture
 - parallel processing is implemented to speed up processing
	 - divided into two independent sections
		 - bus interface unit
			 - 16 bit bidirectional databus
			 - 20 bit address bus
			 - performs
				 - instruction fetching
				 - reading and write data of operands for memory
				 - input and output of data for peripherals
				 - functions related to instruction and data acquisition
			 - has the
				 - segment registers
				 - instruction pointer
				 - address generation adder
				 - bus control logic
				 - instruction queue
		 - execution unit
			 - responsible for decoding and executing instructions
			 - has the
				 - alu
				 - status and control flags
				 - GPR - general purpose registers
				 - operand registers
			 - performs instructions on top of the queue in the BIU
				 - decodes the generated operands if needed
				 - passes them to the instruction unit
				 - requests to perform the read / write cycles to memory or IO
				 - perform operation specified by the instruction on the operands
				 - tests the status and control flags and updates them based on the results / executing of the instruction
 - pipelining
	 - fetching the next instruction while current instruction executes
	 - when the eu is decoding an instruction / executing an instruction, the biu fetches up to six instruction bytes for the next instruction
	 - biu stores prefetched bytes in a register called a queue
	 - when the eu is ready, it fetches the next instruction from the queue
		 - faster than addressing from system memory and waiting
	 - queue must be dumped only when performing a jmp / call instruction
		 - greatly speeds up processing
## Registers
- 14 registers split into four groups
- **general purpose registers**
	- accumulator register - AL and AH combine into AX
		- AL - lower byte
		- AH - higher byte
		- can be used for io operations and string manipulation
		- stores operands for arithmetic operations like divide / rotate
	- base register
		- BL and BH - combine into BX
		- contains a data pointer used for based / based index and register indirect addressing
			- holds base location of a memory location within a data segment
	- count register
		- CL and CH combine into CX
		- loop / shift and rotate instructions and a counter in string manipulation
	- data register
		- DL and DH combine into DX
		- port number in io operations
		- store the high order word for resulting number when performing 32 bit multiplication and divide
- **index and pointer register**
	- used to store the offset address of memory locations relative to the segment registers
	- source index - 16 bit register for index / based index / register indirect addressing (SI)
		- source data address in string manipulation instructions
		- conjunction with ds register to point to data locations in data segment
	- destination address (DI)
		- used with extra segment register in string operations
		- indexed / base index / register indirect addressing
		- destination address in string manipulation instructions
	- DI and SI are used to hold addresses
		- string operations where strings may be copied, searched, or otherwise manipulated
	- stack pointer - 16 bit register pointing to program stack
		- is used to hold the address at the top of the stack
		- grows downwards on x86 systems
		- last piece of data stored in the stack
	- base pointer - 16 bit register pointing to program stack segment
		- used by subroutines to locate variables that were passed on stack by calling program
		- used for based, based index or register indirect addressing
		- address in the stack where the list of variables begin
	- instruction pointer is a 16 bit register
		- important is it controls which instructions the CPU executes
		- also called the program counter
		- cpu checks the program counter to ascertain which instruction to carry out next
		- updates the program counter to point to the next instruction
- **segment register**
	- most registers contain instruction offsets within 64KB segments of memory
		- 4 different 64kb segments for instructions, stack, data, and extra data
		- only our one of four segments are available at one time
		- size of address bus of 8086 is 20 bits wide, for 1MB of memory, partitioned into 16 parts named segments
	- see **memory segmentation below for more info**
	- cannot be used for arithmetic operations
	- to specify where in 1mb of processor memory these 4 segments are located, the processor uses a segment register for each
		- code segment - 16 bit register containing address of 64kb segment with processor instructions
			- used when being referenced by the instruction pointer
			- cannot be changed directly and is only updatable during far jump / far call and far return instructions
		- stack segment - 16 bit register containing the address of the 64kb segment of program stack
			- all data referenced by the stack pointer and base pointer is located in the stack segment
			- register can be changed using the POP instruction
		- data segment
			- 64kb segment where program data resides
			- all data referenced by the data registers and index registers are located in the data segment
			- can be changed using pop and lds instructions
		- extra segment
			- starting address of extra segment
			- provided for programs that need to access a second data segment
- **flag register**
	- determines the current state of the proc
	- modified by the cpu after mathematical operations / allows to determine the type of result and to determine conditions to transfer control to other parts of the program
	- has 9 flags and they fall into two categories
		- status flags / conditional flags
			- result of last arithmetic or logical instruction executed
			- carry flag - indicates an overflow condition for unsigned integer arithmetic / used
				- also used for multiple precision arithmetic
			- auxiliary flag
				- if an alu operation borrows from a lower nibble, the AF flag is set
				- used internally for binary to bcd conversion
			- parity flag - used to indicate the parity of the result
				- lower 8 bit contains an even number of 1s - parity is set
				- otherwise reset
			- zero flag - result of arithmetic operation is zero
			- sign flag - magnitude format indicated by the most significant bit
				- if the operation is negative - sign flag is set
			- overflow flag - when signed numbers are added / subtracted
				- result has exceeded the capacity of the machine
		- control flags
			- set / reset deliberately to control the operations of the execution unit
			- trap flag
				- single step control
				- execute one instruction of program at a time for debugging
				- programs are run in single step mode
			- interrupt flag
				- interrupt enable / disable flag
				- maskable interrupt of 8086 is enabled and if it reset the interrupt is disabled
				- set by instruction SIT and can be cleared using instruction CLI
			- direction flag
				- used in string operation
				- if set - string bytes are accessed from high mem to low mem
				- if reset - string bytes are accessed from low mem to address high mem
## Memory segmentation
 - memory in an 8086 based system is segmented memory
	 - allows memory capacity to be 1MB although the effective addresses to be handled are of 16 bit size
	 - placing of code, data, stack portions of the same program in different parts of memory
		 - data and code protection
	 - permits a program to put data into different areas of memory when the program is first executed
 - available to access 1MB of physical memory divided into 16 segments
	 - each segment is 64kb in size and is addressed using one of the segment registers
	 - 16 bit content of a segment register points to the starting location of a particular segment
		 - 0000H to F000H
	 - to address a specific memory location within a segment, an offset address is used
		 - offset values are 0000H to FFFFH resulting in a total address range of FFFFFH
			 - FFFFH is 20 bits which is the address bus width of the 8086
 - a program can access only 4 segments at a time
 - physical address = segment address x 10H + offset address
 - beginning address of a segment must be an address divisible by 16
 - 16-bit content of segment register gives the starting address of the segment
	 - all segments can overlap
	 - offset address can reference a memory location within the segment
## Addressing modes
 - **immediate addressing mode**
	 - immediate data is part of instruction and appears in the form of successive byte 
	 - transfers immediate byte or word of data to the dest register
	 - use of constant as operand
	 - `mov ax, 005h`
		 - move 5 in hex to ax
 - **register addressing mode**
	 - data is stored in a register and is referred using a particular register
	 - all registers except program counter can be used here
	 - `mov ax, bx`
 - **direct addressing mode**
	 - a 16 bit memory address provided as an offset in the instruction as a part of it
	 - `mov ax, [5000H]`
		 - move the contents of the memory space 5000H into ax register with the data segment taken into account
	 - the actual address here is 10H x DS + 5000H
 - **register indirect addressing mode**
	 - address of memory location is determined using an offset register
	 - offset of data is either in BX / SI or DI register and the segment is DS or ES (refer to segment register descriptions above)
	 - data is available at the address pointed to by BX / SI or DI in the default data segment
	 - `mov ax, [bx]`
		 - dereference bx and add it to 10H x DS to get the actual address
 - **based addressing mode**
	 - the effective address of an operand is obtained by adding a direct or indirect replacement of the contents of either the base register bx or base pointer register
	 - `mov [bx] + 1234H, AL`
		 - move the contents of lower register AL into DS x 10 + (BX + 1234H)
		 - we add an offset into the memory address located in BX and use that to calculate the effective address
 - **indexed addressing mode**
	 - effective address of the operand is added by adding a direct or indirect displacement to the contents of the SI / DI register
	 - is the same as based addressing mode but instead we do it with SI or DI register
 - **based index addressing mode**
	 - effective address is calculated by adding content of a base register to a content of an index register and the default segment register may either be es or ds
	 - `mov ax, [bx][si]`
		 - bx - base register
		 - si - index register
		 - EA = 10H x DS + value of BX + value of SI
 - **based index with displacement mode**
	 - actual address is formed by adding an 8 bit or 16 bit displacement with the same of any one of the base register and any one of the index register in a default segment
	 - `mox ax, 50H[bx][si]`
		 - AA = 10H x DS + BX + SI + 50H

 - **addressing mode byte** - one byte of object code that specifies the memory addressing mode
	 - may have one or two additional displacement bytes associated with it
	 - is always the second byte of the object code, unless a prefix instruction has been included
	 - first 2 bits - the mod field is used to distinguish between memory and register addressing
		 - memory addressing - specifies how many displacement bytes follow the addressing mode byte
		 - 00 - memory addressing mode (r/m specifies the addressing option) and there are no displacement bytes
		 - 01 - memory addressing mode (there is one displacement byte following the instruction)
			 - when this number is used in mem address calculation, the number is sign extended to 16 bits
		 - 10 - memory addressing mode
			 - r/m specifies the addressing option
			 - there are two displacement bytes
				 - first byte - lower eight bits of the displacement
				 - second byte - higher 8 bits of the displacement
			 - when this number is used in calculation, the number is treated as an unsigned 16 bit number
		 - 11 - register addressing mode
			 - r/m specifies a register, used in conjunction with the `w bit` to determine if an 8-bit or 16 bit register is selected
	 - next 3 bits
		 - form the reg field - defines which register will be used in the operation / can also specify instruction
			 - used with the w bit in selection of the register to be used in the operation
			 - **w bit is part of the instruction opcode** whether or not a 8 bit or 16 bit operation is performed
	 - last 3 bits
		 - form the r/m field
		 - used in conjunction with the mod field to specify the addressing mode

Every addressing mode has a standard default segment register
 - can select an alternative segment register by using a override prefix
	 - place `001rr110` before the instruction whose default segment register is to be overridden
		 - `rr` is `[ES, CS, SS, DS]`
 - stack reference instructions always use the ss register as the segment register
 - string instructions that use the DI register always use the ES register as the segment register
 - string instructions where both SI and DI are used, the segment override prefix overrides the SI offset's segment register
 - cannot be used with program memory addressing, all instruction fetches are relative to the CS segment register
## Instruction set of 8086
 - data transfer instructions
	 - transfers data from a source to a destination
	 - data may be of any type
	 - mov instruction
		 - general purpose instruction to transfer byte or word to from register to register, memory to register / register to memory or with immediate addressing
	 - xchg instruction
		 - exchanges contents of destination and source
		 - destination and source can be register and register or register and memory location
		 - xchg cannot interchange the value of 2 memory locations
	 - lea instruction
		 - offset of variable or memory location named as source
		 - `lea bx, m`
			 - load bx with offset of m in DS
			 - 10H x DS + m is the real address and the content is in bx
	 - push instruction
		 - decrements stack pointer by two and copies word from source to the location where stack pointer now points
			 - stack grows down and 2 is taken because a word is 2 bytes
			 - most significant byte to sp-1
			 - least significant byte to sp-2
		 - does not affect any flags
	 - pop instruction
		 - word from stack location to a gpr, a segment register or memory location
			 - stack pointer is incremented by two
			 - `pop cx`
				 - pop the value from the stack and move it to cx
	 - in out
		 - copy data from a port to the accumulator
			 - 8 bit - data goes to and from the AL
			 - 16-bit, entire AX register is taken
		 - can be used as direct and indirect addressing modes
 - arithmetic instructions
	 - perform arithmetic calculations, classified into four groups
	 - add instruction
		 - add the contents of destination with that of source and store result in destination
		 - `add destination, source`
	 - adc instruction
		 - add instruction but with the carry flag bit (could be set as a result of the previous calculation)
		 - all condition code flags are affected by this instruction
	 - sub instruction
		 - subtract the current contents fo the dest with that of source and store the result in the destination
		 - register and or memory locations
		 - `sub destination, source`
	 - sbb - borrow instruction 
		 - subtracts the source operand and the borrow instruction which are set by the results of previous calculations
			 - aka subtract 1 from the subtraction operation if borrow flag is set
		 - result is stored in the destination operand. all flags are affected by condition code by this instruction
	 - cmp - compares the source operand with the destination operand
		 - source - register / immediate / memory location
		 - destination - register or memory location
		 - subtracts the source operand from the dest but only affects the flags
			 - zero flag if they are equal
			 - carry flag is set if source > dest
			 - carry flag is reset if source < dest
	 - inc & dec instructions
		 - increment and decrement the counter of the specified destination by one
		 - all flags are set
		 - only accepts registers
	 - mul instruction - multiply unsigned bytes or words
		 - mul op - multiplies an unsigned multiplication of the accumulator by the operand specified by the op
			 - when the operand is 8 bytes, the entire resulting word is stored in AX
			 - when the operand is 16 bytes, the result is 2 words, so the higher order byte is stored in DX
		 - imul - performs signed multiplication
			 - stores result in AX when the operand is a byte
			 - stores higher order byte in DX when operand is a word
	 - div - unsigned divide
		 - div op
			 - operand is a register or memory
				 - AL = AX / operand
					 - result is a byte if divisor is a byte
				 - AH = remainder of the result
				 - divide a byte with a byte, you must first put the numerator byte in AL and fill AH with 0s
					 - sub AH, AH instruction
			 - operand is a word
				 - AX = (DX AX) / operand
					 - result is 2bytes if divisor is two bytes
				 - DX - remainder modulus
					 - remainder is 2bytes if divisor is two bytes
				 - if you try to divide by zero or quotient is too large to fill in AX, then the 8086 would send a type 0 interrupt
				 - divide a word with a word
					 - numerator word in AX and fill DX with 0s
						 - sub dx, dx
		 - idiv operation
			 - divide a signed word with a signed byte or to divide a signed double word by a signed word
 - bit manipulation instructions
	 - bit wise operations
	 - and instruction
		 - logically ands each bit of the source and dest byte and store in dest byte
			 - source can be imm, register / memory, deref reg and mem
			 - cf and of are made zero, rest are affected except af (undefined)
	 - or instruction
		 - logically or each bit of source byte / word with corresponding bit in the destination and store in destination
	 - xor instruction
		 - similar with and and or
 - shift / rotate instructions
	 - moves the binary data to the left and right by shifting them within the register or memory location
	 - shl/sal
		 - both instructions shift to the left
		 - MSB is set in CF
		 - LSB is set to 0
		 - all flags are affected
		 - destination can be byte size or word size / register or memory location
		 - number of shifts is indicated by the count
	 - shr
		 - each instruction shifts each bit in the specified destination to the right and 0 is stored in the msb
		 - lsb is stored in the carry flag
		 - destination can be byte size or word size, register or memory location
		 - number of shifts is indicated by the count
	 - rol
		 - rotates all bits in a specified byte or word to the left some number of positions
		 - MSB is set as new LSB and a new CF
		 - same constraints
	 - ror
		 - rotates all bits to the right by a number of times
	 - rcr
		 - rotate all the bits of a specified byte or word to the right by a number of positions along with the carry flag
		 - lsb is placed in a new carry flag and previous carry is placed in the new msb
 - string instructions
	 - functions on blocks of memory
		 - array handling / tables and records
	 - move byte or string using movsb / movsw
		 - copies a byte or word from a location in the data segment to a location in the data segment
		 - offset of source is in SI and the destination is in DI
		 - multi byte /word transfers, the count is stored in the CX register
	 - compare string using cmpsb / cmpsw
		 - rep - repeat instruction until cx = 0
		 - repe/repz - repeat instruction until cx = 0 or zf != 1
		 - repne/repnz - repeat instruction until cx = 0 or zf = 1
	 - scan string using scasb /scasw
	 - load string using lodsb / lodsw
		 - copies a byte/word from a string location pointed to by SI to AL
		 - LODSB - loads byte
		 - LODSW - loads word
	 - store string using stosb / stosw
		 - store a byte contained in AL / AX to the offset contained in the DI register
		 - not affect flag
		 - DI is automatically incremented / decremented based on the DF flag
		 - STOSB - byte in AL to ES:DI
			 - di incremented/decremented by only 1 since only 1 byte is being transferred
		 - STOSW - byte in AX to ES:DI
			 - di incremented / decremented by 2 since 2 bytes are being transferred (2 bytes in a word)
	 - compare instructions
		 - compared strings, byte wise or word wise
		 - affected by subtraction of content pointed by DI from that pointed by si
			 - si and di registers are incremented/decremented either by 1 or by 2 depending on byte and word
		 - CMPSW - compare word
		 - CMPSB - compare byte
 - control transfer instructions
	 - transfer program control from one address to another
	 - unconditional transfer instructions
		 - no status requirements are imposed for the jump to occur
		 - always takes place to change the execution sequence
		 - jmp - jump to the address specified by the operand
			 - `label: jmp short / near / far address`
			 - within the same segment may be short or near (or far if the destination is a procedure with the FAR attribute)
				 - within -128 bytes to 127 bytes, short jump
					 - assembler generates one byte (EB) for the operation and one byte for the operand
						 - operand is an offset value that the processor adds to the ip register
				 - when exceeding -128 to 127 bytes, it's a near jump
					 - generates code E9 and 2 byte operand on 8086 and 80286
			 - jump may be backward or forward
				 - backward jump is when the assembler has already encountered the designated operand within 128 bytes
					 - 2 byte instruction
				 - forward jump
					 - doesn't know at this point whether the jump is short / near
					 - some assemblers assume near and generate a 3 byte `EBxx90` instruction
						 - xx is the offset and 90 is the NOP
					 - can force to assume short using SHORT operator and generate a two byte `EBXX` operation
	 - conditional transfer instructions
		 - status conditions that exist at the moment the jump instruction is executed will decide whether or not the jump will occur
			 - status flags = carry, parity, overflow flag
			 - if true, then jump takes place
			 - otherwise execution continues with the next sequential instruction of the program
			 - **distance of a conditional jump must be short**
		 - `j<cc>` - conditional jump
			 - if specified condition cc is true, jump to address specified by the operand
			 - no flags are affected
		 - jnz - jump to specified operand if zero flag is non zero
			 - control drops through next instruction if cx is zero
			 - operand is distance from end of the instruction to the address of a20
	 - iteration control instructions
		 - loop instruction decrements cx, if it is non zero, control transfers to the operand address
	 - interrupt instructions
 - flag manipulation instruction
	 - stc - sets carry flag to one
	 - clc - clears carry flag to zero
	 - cmc - complements the carry flag
	 - std - set direction flag to one
		 - decrements automatically after execution of string instruction
	 - cld - clear direction flag to zero
	 - sti - set interrupt flag to one
		 - enables INTR interrupt of 8086
	 - cli - resets interrupt flag to 0
		 - will not respond to an interrupt signal on the INTR input
 - external hardware sync instructions
	 - hlt - halt processor
	 - wait - wait for activity in the test pin
	 - esc - escape to external processor interface
	 - lock - lock bus during next instruction
	 - nop - no operation
## Interrupts
interrupts - halts microprocessor temporarily to work on a different task and then return to its previous task
 - external event / signal that requires attention of cpu
 - halt allows peripheral devices to access the microprocessor
 - completes the execution of the current instruction and starts the execution of an ISR or interrupt handler
	 - tells processor what to do when the interrupt occurs
	 - control returns back to main routine where it was interrupted
 - divided into two types
	 - external hardware interrupts
		 - sending a signal through a specified pin to the microprocessor
		 - intr and nmi pins
	 - internal software interrupts
		 - initiated by the state of the cpu
			 - ex: divide by zero exception
			 - instruction
		 - interrupts the normal execution of a program of the microprocessor
 - two interrupt pins called nmi and intr
	 - nmi - non maskable interrupt
		 - has to setop the main program to execute the nmi service routine
		 - power failure
		 - critical response time
		 - non recoverable hardware errors
		 - watchdog interrupt
		 - memory parity errors
	 - intr - maskable interrupt with lower priority
		 - processor has the ability to reject an interrupt
			 - referred to by masking or disabling
			 - when the processor accepts an interrupt - unmasking / enabling
			 - IF flag can be set to 1 to unmask or enable all
			 - IF flag can be set to 0 to mask / disable all interrupts except nmi
		 - 256 interrupt types through instruction INT n
			 - type 0 - divide by zero
			 - type 1- single step instruction during debugging
			 - type 2- non maskable nmi interrupt
			 - type 3 - break point interrupt
			 - type 4 - interrupt represents overflow interrupt
	 - inta - interrupt acknowledge
 - interrupt vector table
	 - vector of 256 total interrupts on the first 1kb of memory from 0000h to 03ffh
	 - each vector is a segment and offset as a lookup or jump table to memory address of bios ISR or dos ISR
		 - bios isr is from f000h to ffffh
		 - Each size of interrupt vector is 4 bytes
			 - 2 bytes is segment and 2 bytes is offset
	 - tasks performed when finding an interrupt
		 - flag register is pushed into stack
			 - sp decrements by 2
		 - value of starting memory address of code segment is pushed into the stack
		 - IP is also pushed into the stack
		 - ip is loaded from word location interrupt type * 04
			 - 4 bytes per segment, type 0 interrupt is on mem location 0
			 - ip comes first
		 - cs is loaded from the next word location
		 - interrupt and trap flag are reset to 0